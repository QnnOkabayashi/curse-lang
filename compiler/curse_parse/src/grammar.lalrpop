use crate::{lexer::*, Ast, Error};
use curse_ast::*;

grammar<'ast, 'input>(ast: &'ast Ast<'ast, 'input>, errors: &mut Vec<Error>);

extern {
    type Location = usize;
    type Error = LexError;

    // Any changes here must also be reflected in:
    // - curse_parse/src/lexer.rs
    // - curse_ast/src/tok.rs
    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        "named type literal" => Token::NamedType(<tok::NamedType<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "struct" => Token::Struct(<tok::Struct>),
        "choice" => Token::Choice(<tok::Choice>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Eq(<tok::Eq>),
        "<" => Token::Lt(<tok::Lt>),
        ">" => Token::Gt(<tok::Gt>),
        "<=" => Token::Le(<tok::Le>),
        ">=" => Token::Ge(<tok::Ge>),

        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
    }
}

/// === Term Aliases ===

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

NamedType: tok::NamedType<'input> = "named type literal";


/// === Program ===

pub Program: Option<Program<'ast, 'input>> = {
    FnDef => <>.map(|def| Program::new().with_fn_def(def)),
    ChoiceDef => <>.map(|def| Program::new().with_choice_def(def)),

    Program FnDef => match (<>) {
        (Some(program), Some(def)) => Some(program.with_fn_def(def)),
        _ => None,
    },
    Program ChoiceDef => match (<>) {
        (Some(program), Some(def)) => Some(program.with_choice_def(def)),
        _ => None,
    },
};


/// === Function Definitions ===

FnDef: Option<FnDef<'ast, 'input>> =
    "fn" Ident ((NamedType)* ":" Type "=")? Closure => match (<>) {
    (fn_, ident, Some((generics, colon, Some(ty), equal)), Some(function)) => {
        Some(FnDef::new(fn_, ident, Some(TypeSig::new(generics, colon, ty, equal)), function))
    }
    (fn_, ident, None, Some(function)) => {
        Some(FnDef::new(fn_, ident, None, function))
    }
    _ => None,
};
    

/// === Type Defs ===

NamedField: Option<NamedField<'ast, 'input>> = Ident ":" Type => NamedField::from_grammar(<>);

FieldKind: Option<FieldKind<'ast, 'input>> = {
    Type => FieldKind::newtype_from_grammar(<>),
    "{" (NamedField ",")* NamedField? "}" => FieldKind::record_from_grammar(<>),
};

StructDef: Option<StructDef<'ast, 'input>> = {
    "struct" NamedType (NamedType)* FieldKind => StructDef::from_grammar(<>),
};

ChoiceDef: Option<ChoiceDef<'ast, 'input>> = {
    "choice" NamedType (NamedType)* "{" (VariantDef ",")* VariantDef? "}" => ChoiceDef::from_grammar(<>),
};
    
VariantDef: Option<VariantDef<'ast, 'input>> = NamedType FieldKind => VariantDef::from_grammar(<>);


/// === Chaos ===

StartType: Option<&'ast Type<'ast, 'input>> = {
    NamedType => Some(ast.typ(Type::Named(<>))),
    Tuple<Type> => <>.fold().map(|tup| ast.typ(Type::Tuple(tup))),
    "(" <Type> ")",
    ! => {
        errors.push(<>.error.into());
        None
    }
};

Type = {
    StartType StartType "->" Type => match (<>) {
        (Some(lhs), Some(rhs), arrow, Some(res)) => {
            Some(ast.typ(Type::Function(TypeFunction::new(lhs, rhs, arrow, res))))
        }
        _ => None,
    },
    StartType,
};

Pat: &'ast ExprPat<'ast, 'input> = {
    Lit => ast.pat(ExprPat::Lit(<>)),
    Tuple<Pat> => ast.pat(ExprPat::Tuple(<>)),
};

Paren: Option<ExprParen<'ast, 'input>> = "(" EndExpr ")" => match (<>) {
    (lparen, Some(expr), rparen) => Some(ExprParen::new(lparen, expr, rparen)),
    _ => None,
};

Tuple<T>: PatTuple<T> = {
    "(" ")" => PatTuple::empty(<>),
    "(" T "," (T ",")* T? ")" => PatTuple::nonempty(<>),
};

Symbol: ExprSymbol = {
    "+" => ExprSymbol::Plus(<>),
    "-" => ExprSymbol::Minus(<>),
    "*" => ExprSymbol::Star(<>),
    "." => ExprSymbol::Dot(<>),
    ".." => ExprSymbol::DotDot(<>),
    ";" => ExprSymbol::Semi(<>),
    "%" => ExprSymbol::Percent(<>),
    "/" => ExprSymbol::Slash(<>),
    "=" => ExprSymbol::Eq(<>),
    "<" => ExprSymbol::Lt(<>),
    ">" => ExprSymbol::Gt(<>),
    "<=" => ExprSymbol::Le(<>),
    ">=" => ExprSymbol::Ge(<>),
};

Lit: ExprLit<'input> = {
    Integer => ExprLit::Integer(<>),
    Ident => ExprLit::Ident(<>),
    "true" => ExprLit::True(<>),
    "false" => ExprLit::False(<>),
};

Closure: Option<ExprClosure<'ast, 'input>> = {
    Arm => <>.map(ExprClosure::new_non_piecewise),
    "{" Arm ClosureTail? ","? "}" => match (<>) {
        (lbrace, Some(head), Some(Ok(tail)), trailing_comma, rbrace) => {
            Some(ExprClosure::new_piecewise(lbrace, head, tail, trailing_comma, rbrace))
        }
        (lbrace, Some(head), None, trailing_comma, rbrace) => {
            Some(ExprClosure::new_piecewise(lbrace, head, vec![], trailing_comma, rbrace))
        }
        _ => None
    }
};

ClosureTail: Result<Vec<(tok::Comma, ExprArm<'ast, 'input>)>, ()> = {
    "," Arm => match (<>) {
        (comma, Some(arm)) => Ok(vec![(comma, arm)]),
        _ => Err(()),
    },
    ClosureTail "," Arm => match (<>) {
        (Ok(mut tail), comma, Some(arm)) => {
            tail.push((comma, arm));
            Ok(tail)
        }
        _ => Err(()),
    }
}

Arm: Option<ExprArm<'ast, 'input>> = {
    "|" "|" EndExpr => match (<>) {
        (open, close, Some(body)) => Some(ExprArm::new(open, ExprParams::Zero, close, body)),
        _ => None,
    },
    "|" Param "|" EndExpr => match (<>) {
        (open, Some(lhs), close, Some(body)) => Some(ExprArm::new(open, ExprParams::One(lhs), close, body)),
        _ => None,
    },
    "|" Param "," Param "|" EndExpr => match (<>) {
        (open, Some(lhs), comma, Some(rhs), close, Some(body)) => Some(ExprArm::new(open, ExprParams::Two(lhs, comma, rhs), close, body)),
        _ => None,
    },
};

Param: Option<ExprParam<'ast, 'input>> = Pat (":" Type)? => match (<>) {
    (pat, Some((colon, Some(ty)))) => {
        Some(ExprParam::new(pat, Some((colon, ty))))
    },
    (pat, None) => {
        Some(ExprParam::new(pat, None))
    }
    _ => None,
};

// Hmm... We can never have a tuple as a function, should we make that a parsing issue?
Appl<Rhs>: Option<ExprAppl<'ast, 'input>> = Expr Applyable Rhs => match (<>) {
    (Some(lhs), Some(function), Some(rhs)) => Some(ExprAppl::new(lhs, function, rhs)),
    _ => None,
};

Applyable: Option<&'ast Expr<'ast, 'input>> = {
    Paren => <>.map(|paren| ast.expr(Expr::Paren(paren))),
    Symbol => Some(ast.expr(Expr::Symbol(<>))),
    Lit => Some(ast.expr(Expr::Lit(<>))),
    ! => {
        errors.push(<>.error.into());
        None
    }
};

Field<T>: () = {
    Ident ":" T => (),
};

StructFieldKind<T>: () = {
    "{" "}" => (),
    "{" T "," (T ",")* T? "}" => (),
};

Constructor: () = {
    NamedType => (), // unit struct constructor
    NamedType Tuple<EndExpr> => (), // tuple struct constructor
    NamedType StructFieldKind<Field<Ident>> => (), // named fields struct constructor
};

Term: Option<&'ast Expr<'ast, 'input>> = {
    Applyable,
    Tuple<EndExpr> => <>.fold().map(|tup| ast.expr(Expr::Tuple(tup))),
};

EndTerm = {
    Term,
    Closure => <>.map(|closure| ast.expr(Expr::Closure(closure))),
};

Expr = {
    Term,
    Appl<Term> => <>.map(|appl| ast.expr(Expr::Appl(appl))),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => <>.map(|appl| ast.expr(Expr::Appl(appl))),
    Expr Closure => match (<>) {
        (Some(_expr), Some(closure)) => {
            errors.push(Error::ClosureApplMissingRhs {
                location: closure.span().0,
            });
            None
        }
        _ => None,
    },
}
