use crate::{lexer::*, Ast, Error};
use curse_ast::*;

grammar<'ast, 'input>(ast: &'ast Ast<'ast, 'input>, errors: &mut Vec<Error>);

extern {
    type Location = usize;
    type Error = LexError;

    // Any changes here must also be reflected in:
    // - curse_parse/src/lexer.rs
    // - curse_ast/src/tok.rs
    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        "named type literal" => Token::NamedType(<tok::NamedType<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "struct" => Token::Struct(<tok::Struct>),
        "choice" => Token::Choice(<tok::Choice>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Eq(<tok::Eq>),
        "<" => Token::Lt(<tok::Lt>),
        ">" => Token::Gt(<tok::Gt>),
        "<=" => Token::Le(<tok::Le>),
        ">=" => Token::Ge(<tok::Ge>),

        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
    }
}

/// === Term Aliases ===

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

NamedType: tok::NamedType<'input> = "named type literal";


/// === Program ===

pub Program: Res<Program<'ast, 'input>> = {
    FnDef => <>.map(|def| Program::new().with_fn_def(def)),
    ChoiceDef => <>.map(|def| Program::new().with_choice_def(def)),

    Program FnDef => match (<>) {
        (Ok(program), Ok(def)) => Ok(program.with_fn_def(def)),
        _ => Err(ParseError),
    },
    Program ChoiceDef => match (<>) {
        (Ok(program), Ok(def)) => Ok(program.with_choice_def(def)),
        _ => Err(ParseError),
    },
};


/// === Function Definitions ===

FnDef: Res<FnDef<'ast, 'input>> = "fn" Ident TypeSig? Closure => FnDef::from_grammar(<>);

TypeSig: Res<TypeSig<'ast, 'input>> = NamedType* ":" Type "=" => TypeSig::from_grammar(<>);
    

/// === Type Defs ===

NamedField: Res<NamedField<'ast, 'input>> = Ident ":" Type => NamedField::from_grammar(<>);

FieldKind: Res<FieldKind<'ast, 'input>> = {
    Type => FieldKind::newtype_from_grammar(<>),
    "{" (NamedField ",")* NamedField? "}" => FieldKind::record_from_grammar(<>),
};

StructDef: Res<StructDef<'ast, 'input>> = {
    "struct" NamedType (NamedType)* FieldKind => StructDef::from_grammar(<>),
};

ChoiceDef: Res<ChoiceDef<'ast, 'input>> = {
    "choice" NamedType (NamedType)* "{" (VariantDef ",")* VariantDef? "}" => ChoiceDef::from_grammar(<>),
};
    
VariantDef: Res<VariantDef<'ast, 'input>> = NamedType FieldKind => VariantDef::from_grammar(<>);


/// === Chaos ===

StartType: Res<&'ast Type<'ast, 'input>> = {
    NamedType => Ok(ast.ty(Type::named_from_grammar(<>))),
    Tuple<Type> => ast.try_ty(Type::tuple_from_grammar(<>)),
    "(" <Type> ")",
    ! => {
        errors.push(<>.error.into());
        Err(ParseError)
    }
};

Type = {
    StartType StartType "->" Type => ast.try_ty(Type::function_from_grammar(<>)),
    StartType,
};

Pat: &'ast ExprPat<'ast, 'input> = {
    Lit => ast.pat(ExprPat::Lit(<>)),
    Tuple<Pat> => ast.pat(ExprPat::Tuple(<>)),
};

Tuple<T>: PatTuple<T> = {
    "(" ")" => PatTuple::unit_from_grammar(<>),
    "(" T "," (T ",")* T? ")" => PatTuple::nonempty_from_grammar(<>),
};

Symbol: ExprSymbol = {
    "+" => ExprSymbol::Plus(<>),
    "-" => ExprSymbol::Minus(<>),
    "*" => ExprSymbol::Star(<>),
    "." => ExprSymbol::Dot(<>),
    ".." => ExprSymbol::DotDot(<>),
    ";" => ExprSymbol::Semi(<>),
    "%" => ExprSymbol::Percent(<>),
    "/" => ExprSymbol::Slash(<>),
    "=" => ExprSymbol::Eq(<>),
    "<" => ExprSymbol::Lt(<>),
    ">" => ExprSymbol::Gt(<>),
    "<=" => ExprSymbol::Le(<>),
    ">=" => ExprSymbol::Ge(<>),
};

Lit: ExprLit<'input> = {
    Integer => ExprLit::Integer(<>),
    Ident => ExprLit::Ident(<>),
    "true" => ExprLit::True(<>),
    "false" => ExprLit::False(<>),
};

NonpiecewiseClosure: Res<ExprClosure<'ast, 'input>> = Arm => ExprClosure::nonpiecewise_from_grammar(<>);

PiecewiseClosure: Res<ExprClosure<'ast, 'input>> = "{" Arm ("," Arm)* ","? "}" => ExprClosure::piecewise_from_grammar(<>);

Closure = {
    NonpiecewiseClosure,
    PiecewiseClosure,
};

Arm: Res<ExprArm<'ast, 'input>> = "|" (Param ",")* Param? "|" EndExpr => ExprArm::from_grammar(<>);

Param: Res<ExprParam<'ast, 'input>> = Pat (":" Type)? => ExprParam::from_grammar(<>);

Appl<Rhs>: Res<ExprAppl<'ast, 'input>> = Expr Term Rhs => ExprAppl::from_grammar(<>);

Term: Res<&'ast Expr<'ast, 'input>> = {
    "(" EndExpr ")" => ast.try_expr(Expr::paren_from_grammar(<>)),
    Symbol => Ok(ast.expr(Expr::Symbol(<>))),
    Lit => Ok(ast.expr(Expr::Lit(<>))),
    Tuple<EndExpr> => ast.try_expr(Expr::tuple_from_grammar(<>)),
    PiecewiseClosure => ast.try_expr(Expr::closure_from_grammar(<>)),
    ! => {
        errors.push(<>.error.into());
        Err(ParseError)
    },
};

EndTerm = {
    Term,
    NonpiecewiseClosure => ast.try_expr(Expr::closure_from_grammar(<>)),
};

Expr = {
    Term,
    Appl<Term> => ast.try_expr(Expr::appl_from_grammar(<>)),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => ast.try_expr(Expr::appl_from_grammar(<>)),

    // For nice diagnostics
    Expr Closure => match (<>) {
        (Ok(_expr), Ok(closure)) => {
            errors.push(Error::ClosureApplMissingRhs {
                location: closure.span().0,
            });
            Err(ParseError)
        }
        _ => Err(ParseError),
    },
}
