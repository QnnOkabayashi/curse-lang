use crate::{lexer::*, Arena, Error, parse};
use curse_ast::{
    tok, Appl, Arm, Braced,ChoiceDef, Closure, Constructor, Expr, FieldsKind, FunctionDef, Lit,
    Field, NamedType, Param, Paren, Pat, Program, StructDef, Symbol, Record, Type, GenericArgs, GenericParams,
    VariantDef,
};

grammar<'ast, 'input>(arena: &'ast Arena<'ast, 'input>);

extern {
    type Location = usize;
    type Error = LexError;

    // Any changes here must also be reflected in:
    // - curse_parse/src/lexer.rs
    // - curse_ast/src/tok.rs
    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        "named type literal" => Token::TypeIdent(<tok::TypeIdent<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "struct" => Token::Struct(<tok::Struct>),
        "choice" => Token::Choice(<tok::Choice>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Eq(<tok::Eq>),
        "<" => Token::Lt(<tok::Lt>),
        ">" => Token::Gt(<tok::Gt>),
        "<=" => Token::Le(<tok::Le>),
        ">=" => Token::Ge(<tok::Ge>),

        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
    }
}

/// === Term Aliases ===

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

TypeIdent: tok::TypeIdent<'input> = "named type literal";


/// === Program ===

pub Program: Program<'ast, 'input> = {
    FunctionDef => Program::new().with_function_def(<>),
    ChoiceDef => Program::new().with_choice_def(<>),

    Program FunctionDef => Program::with_function_def(<>),
    Program ChoiceDef => Program::with_choice_def(<>),
};

/// === Definitions ===

GenericParams: GenericParams<'input> = {
    TypeIdent => parse::def::generic_single(<>),
    "(" TypeIdent ("*" TypeIdent)* ")" => parse::def::generic_product(<>),
};

ExplicitTypes: ExplicitTypes<'ast, 'input> = {
    GenericsParams? ":" Type => parse::def::explicit_types(<>),
}

FunctionDef: FunctionDef<'ast, 'input> = {
    "fn" Ident ExplicitTypes? "=" Closure => parse::def::function(<>),
};

StructDef: StructDef<'ast, 'input> = {
    "struct" TypeIdent GenericsDecl? "=" Type => parse::def::struct_(<>),
};

ChoiceDef: ChoiceDef<'ast, 'input> = {
    "choice" TypeIdent (TypeIdent)* "=" "{" (VariantDef ",")* VariantDef? "}" => parse::def::choice(<>),
};

Variants: Variants<'ast, 'input> = {
    "|" => Variants::Never(<>),
    "|"? VariantDef ("|" VariantDef)* => parse::def::variants(<>),
}

VariantDef: VariantDef<'ast, 'input> = {
    TypeIdent Type => parse::def::variant(arena, <>),
};


/// === Record ===

Record<T>: Record<T> = {
    "(" (T ",")* T? ")" => parse::record(arena, <>),
}


/// === Types ===

Type: Type<'ast, 'input> = {
    NamedType => Type::Named(<>),
    Record<FieldType> => Type::Record(<>),
    ! => Type::Error,
};

GenericArgs: GenericArgs<'input> = {
    Type => parse::ty::generic_single(arena, <>),
    "(" (Type "*")* Type ")" => parse::ty::generic_product(arena, <>),
};

NamedType: NamedType<'ast, 'input> = {
    TypeIdent GenericArgs? => parse::ty::named(<>),
};

FieldType: FieldType<'ast, 'input> = {
    // Unlike Expr and Pat fields, the type is _not_ optional.
    Ident ":" Type => parse::ty::field(arena, <>),
}

/// === Patterns ===

Pat: Pat<'ast, 'input> = {
    Lit => Pat::Lit(<>),
    Record<PatField> => Pat::Record(<>),
    // TODO(quinn): add struct and choice pats
};

FieldPat: FieldPat<'ast, 'input> = {
    Ident (":" Pat)? => parse::pat::field(<>),
}


/// === Expressions ===

FieldExpr: FieldExpr<'ast, 'input> = {
    Ident (":" EndExpr)? => parse::expr::field(<>),
}

Symbol: Symbol = {
    "+" => Symbol::Plus(<>),
    "-" => Symbol::Minus(<>),
    "*" => Symbol::Star(<>),
    "." => Symbol::Dot(<>),
    ".." => Symbol::DotDot(<>),
    ";" => Symbol::Semi(<>),
    "%" => Symbol::Percent(<>),
    "/" => Symbol::Slash(<>),
    "=" => Symbol::Eq(<>),
    "<" => Symbol::Lt(<>),
    ">" => Symbol::Gt(<>),
    "<=" => Symbol::Le(<>),
    ">=" => Symbol::Ge(<>),
};

Lit: Lit<'input> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
    "true" => Lit::True(<>),
    "false" => Lit::False(<>),
};

ClosureNonpiecewise: Closure<'ast, 'input> = {
    Arm => Closure::NonPiecewise(<>),
};

ClosurePiecewise: Closure<'ast, 'input> = {
    "(" (Arm ",")* ")" => parse::expr::closure_piecewise(<>),
};

Closure = {
    ClosureNonpiecewise,
    ClosurePiecewise,
};

Arm: Arm<'ast, 'input> = {
    "|" (Param ",")* Param? "|" EndExpr => parse::expr::closure_arm(arena, <>),
};

Param: Param<'ast, 'input> = {
    Pat (":" Type)? => parse::expr::closure_param(arena, <>),
};

Constructor: Constructor<'ast, 'input> = {
    TypeIdent EndExpr => parse::expr::constructor(arena, <>),
};

Appl<Rhs>: Appl<'ast, 'input> = {
    Expr Term Rhs => parse::expr::appl(arena, <>),
};

Paren: Paren<'ast, 'input> = {
    "(" EndExpr ")" => parse::expr::paren(arena, <>),
};

Term: Expr<'ast, 'input> = {
    Paren => Expr::Paren(<>),
    Symbol => Expr::Symbol(<>),
    Lit => Expr::Lit(<>),
    Record<FieldExpr> => Expr::Record(<>),
    ClosurePiecewise => Expr::Closure(<>),
    ! => Expr::Error,
};

EndTerm = {
    Term,
    Constructor => Expr::Constructor(<>),
    ClosureNonpiecewise => Expr::Closure(<>),
};

Expr = {
    Term,
    Appl<Term> => Expr::Appl(<>),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => Expr::Appl(<>),
};
