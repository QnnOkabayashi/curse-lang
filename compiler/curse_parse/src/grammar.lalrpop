use crate::{lexer::*, Ast, Error};
use curse_ast::*;

grammar<'ast, 'input>(ast: &'ast Ast<'ast, 'input>, errors: &mut Vec<Error>);

extern {
    type Location = usize;
    type Error = LexError;

    // Any changes here must also be reflected in:
    // - curse_parse/src/lexer.rs
    // - curse_ast/src/tok.rs
    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "else" => Token::Else(<tok::Else>),
        "struct" => Token::Struct(<tok::Struct>),
        "choice" => Token::Choice(<tok::Choice>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),
        "'" => Token::Apostrophe(<tok::Apostrophe>),

        "=" => Token::Eq(<tok::Eq>),
        "<" => Token::Lt(<tok::Lt>),
        ">" => Token::Gt(<tok::Gt>),
        "<=" => Token::Le(<tok::Le>),
        ">=" => Token::Ge(<tok::Ge>),

        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
    }
}

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

pub Program: Option<Program<'ast, 'input>> = {
    FnDef => <>.map(|def| Program::new().with_fn_def(def)),
    Program FnDef => match (<>) {
        (Some(program), Some(def)) => Some(program.with_fn_def(def)),
        _ => None,
    },

    ChoiceDef => <>.map(|def| Program::new().with_choice_def(def)),
    Program ChoiceDef => match (<>) {
        (Some(program), Some(def)) => Some(program.with_choice_def(def)),
        _ => None,
    },
};

FnDef: Option<FnDef<'ast, 'input>> =
    "fn" Ident (Ident)* ":" Type "=" EndExpr => match (<>) {
    (fn_, ident, generics, colon, Some(typ), equal, Some(expr)) => {
        Some(FnDef::new(fn_, ident, generics, colon, typ, equal, expr))
    }
    _ => None,
};
    
ChoiceDef: Option<ChoiceDef<'ast, 'input>> =
    "choice" Ident (Ident)* "{" PunctTrailing<ChoiceVariant, ",">? "}" => match (<>) {
    (choice, ident, generics, lbrace, variants, rbrace) => {
        let variants: Option<ChoiceVariants<'ast, 'input>> = match variants {
            Some((Some(first), rest, trailing)) => rest
                .into_iter()
                .map(|(comma, maybe_variant)| maybe_variant.map(|variant| (comma, variant)))
                .collect::<Option<Vec<_>>>()
                .map(|rest| ChoiceVariants::Variants { first, rest, trailing }),
            None => Some(ChoiceVariants::Empty),
            _ => None,
        };

        variants.map(|variants| {
            ChoiceDef::new(choice, ident, generics, lbrace, variants, rbrace)
        })
    }
};

// A `Sep` punctuated sequence of `T`'s containing at least one `T` without trailing `Sep`'s
// For an optional trailing separator, use `PunctTrailing` instead.
Punct<T, Sep>: (T, Vec<(Sep, T)>) = {
    T => (<>, vec![]),
    Punct<T, Sep> Sep T => match (<>) {
        ((first, mut rest), sep, next) => {
            rest.push((sep, next));
            (first, rest)
        }
    },
};

PunctTrailing<T, Sep>: (T, Vec<(Sep, T)>, Option<Sep>) = {
    Punct<T, Sep> Sep? => match (<>) {
        ((first, rest), trailing) => (first, rest, trailing),
    }
};
    
ChoiceVariant: Option<ChoiceVariant<'ast, 'input>> = {
    "'" Ident Type? => match (<>) {
        (apostrophe, tag, Some(Some(ty))) => {
            Some(ChoiceVariant::new(apostrophe, tag, Some(ty)))
        },
        (apostrophe, name, None) => {
            Some(ChoiceVariant::new(apostrophe, name, None))
        },
        // Parsed a type but it was None, meaning error
        _ => None,
    }
}

StartType: Option<&'ast Type<'ast, 'input>> = {
    Ident => Some(ast.typ(Type::Named(TypeNamed::new(<>)))),
    Tuple<Type> => <>.fold().map(|tup| ast.typ(Type::Tuple(tup))),
    "(" <Type> ")",
    ! => {
        errors.push(<>.error.into());
        None
    }
};

Type = {
    StartType StartType "->" Type => match (<>) {
        (Some(lhs), Some(rhs), arrow, Some(res)) => {
            Some(ast.typ(Type::Function(TypeFunction::new(lhs, rhs, arrow, res))))
        }
        _ => None,
    },
    StartType,
};

Pat: &'ast ExprPat<'ast, 'input> = {
    Lit => ast.pat(ExprPat::Lit(<>)),
    Tuple<Pat> => ast.pat(ExprPat::Tuple(<>)),
};

Paren: Option<ExprParen<'ast, 'input>> = "(" EndExpr ")" => match (<>) {
    (lparen, Some(expr), rparen) => Some(ExprParen::new(lparen, expr, rparen)),
    _ => None,
};

Tuple<T>: PatTuple<T> = {
    "(" ")" => PatTuple::empty(<>),
    "(" T "," (T ",")* T? ")" => PatTuple::nonempty(<>),
};

Symbol: ExprSymbol = {
    "+" => ExprSymbol::Plus(<>),
    "-" => ExprSymbol::Minus(<>),
    "*" => ExprSymbol::Star(<>),
    "." => ExprSymbol::Dot(<>),
    ".." => ExprSymbol::DotDot(<>),
    ";" => ExprSymbol::Semi(<>),
    "%" => ExprSymbol::Percent(<>),
    "/" => ExprSymbol::Slash(<>),
    "=" => ExprSymbol::Eq(<>),
    "<" => ExprSymbol::Lt(<>),
    ">" => ExprSymbol::Gt(<>),
    "<=" => ExprSymbol::Le(<>),
    ">=" => ExprSymbol::Ge(<>),
};

Lit: ExprLit<'input> = {
    Integer => ExprLit::Integer(<>),
    Ident => ExprLit::Ident(<>),
    "true" => ExprLit::True(<>),
    "false" => ExprLit::False(<>),
};

Closure: Option<ExprClosure<'ast, 'input>> = {
    Arm => <>.map(ExprClosure::new_non_piecewise),
    "{" Arm ClosureTail? ","? "}" => match (<>) {
        (lbrace, Some(head), Some(Ok(tail)), trailing_comma, rbrace) => {
            Some(ExprClosure::new_piecewise(lbrace, head, tail, trailing_comma, rbrace))
        }
        (lbrace, Some(head), None, trailing_comma, rbrace) => {
            Some(ExprClosure::new_piecewise(lbrace, head, vec![], trailing_comma, rbrace))
        }
        _ => None
    }
};

ClosureTail: Result<Vec<(tok::Comma, ExprArm<'ast, 'input>)>, ()> = {
    "," Arm => match (<>) {
        (comma, Some(arm)) => Ok(vec![(comma, arm)]),
        _ => Err(()),
    },
    ClosureTail "," Arm => match (<>) {
        (Ok(mut tail), comma, Some(arm)) => {
            tail.push((comma, arm));
            Ok(tail)
        }
        _ => Err(()),
    }
}

Arm: Option<ExprArm<'ast, 'input>> = {
    "|" "|" EndExpr => match (<>) {
        (open, close, Some(body)) => Some(ExprArm::new(open, ExprParams::Zero, close, body)),
        _ => None,
    },
    "|" Param "|" EndExpr => match (<>) {
        (open, Some(lhs), close, Some(body)) => Some(ExprArm::new(open, ExprParams::One(lhs), close, body)),
        _ => None,
    },
    "|" Param "," Param "|" EndExpr => match (<>) {
        (open, Some(lhs), comma, Some(rhs), close, Some(body)) => Some(ExprArm::new(open, ExprParams::Two(lhs, comma, rhs), close, body)),
        _ => None,
    },
};

Param: Option<ExprParam<'ast, 'input>> = Pat (":" Type)? => match (<>) {
    (pat, Some((colon, Some(ty)))) => {
        Some(ExprParam::new(pat, Some((colon, ty))))
    },
    (pat, None) => {
        Some(ExprParam::new(pat, None))
    }
    _ => None,
};

Appl<Rhs>: Option<ExprAppl<'ast, 'input>> = Expr Term Rhs => match (<>) {
    (Some(lhs), Some(function), Some(rhs)) => Some(ExprAppl::new(lhs, function, rhs)),
    _ => None,
};

Term: Option<&'ast Expr<'ast, 'input>> = {
    Paren => <>.map(|paren| ast.expr(Expr::Paren(paren))),
    Symbol => Some(ast.expr(Expr::Symbol(<>))),
    Lit => Some(ast.expr(Expr::Lit(<>))),
    Tuple<EndExpr> => <>.fold().map(|tup| ast.expr(Expr::Tuple(tup))),
    ! => {
        errors.push(<>.error.into());
        None
    }
};

EndTerm = {
    Term,
    Closure => <>.map(|closure| ast.expr(Expr::Closure(closure))),
};

Expr = {
    Term,
    Appl<Term> => <>.map(|appl| ast.expr(Expr::Appl(appl))),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => <>.map(|appl| ast.expr(Expr::Appl(appl))),
    Expr Closure => match (<>) {
        (Some(_expr), Some(closure)) => {
            errors.push(Error::ClosureApplMissingRhs {
                location: closure.span().0,
            });
            None
        }
        _ => None,
    },
}
