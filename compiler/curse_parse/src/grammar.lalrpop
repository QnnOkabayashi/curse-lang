use crate::{lexer::*, Context, Error};
use curse_ast::*;

grammar<'ast, 'input>(ctx: &'ast Context<'ast, 'input>, errors: &mut Vec<Error>);

extern {
    type Location = usize;
    type Error = LexError;

    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "let" => Token::Let(<tok::Let>),
        "else" => Token::Else(<tok::Else>),
        "struct" => Token::Struct(<tok::Struct>),
        "enum" => Token::Enum(<tok::Enum>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Equal(<tok::Equal>),
        "<" => Token::Less(<tok::Less>),
        ">" => Token::Greater(<tok::Greater>),
        "<=" => Token::LessEqual(<tok::LessEqual>),
        ">=" => Token::GreaterEqual(<tok::GreaterEqual>),
        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
    }
}

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

pub Program: Option<Program<'ast, 'input>> = {
    Item => <>.map(Program::new),
    Program Item => match (<>) {
        (Some(program), Some(item)) => Some(program.with_item(item)),
        _ => None,
    },
};

Item: Option<Item<'ast, 'input>> = "let" Ident ":" Type "=" Closure => match (<>) {
    (let_, ident, colon, Some(typ), equal, Some(closure)) => {
        Some(Item::Function(ItemFunction::new(let_, ident, colon, typ, equal, closure)))
    }
    _ => None,
};

StartType: Option<&'ast Type<'ast, 'input>> = {
    Ident => Some(ctx.typ(Type::Named(TypeNamed::new(<>)))),
    Tuple<Type> => <>.fold().map(|tup| ctx.typ(Type::Tuple(tup))),
    "(" <Type> ")",
    ! => {
        errors.push(<>.error.into());
        None
    }
};

Type = {
    StartType StartType "->" Type => match (<>) {
        (Some(lhs), Some(rhs), arrow, Some(res)) => {
            Some(ctx.typ(Type::Function(TypeFunction::new(lhs, rhs, arrow, res))))
        }
        _ => None,
    },
    StartType,
};

Pat: &'ast ExprPat<'ast, 'input> = {
    Lit => ctx.pat(ExprPat::Lit(<>)),
    Tuple<Pat> => ctx.pat(ExprPat::Tuple(<>)),
};

Paren: Option<ExprParen<'ast, 'input>> = "(" EndExpr ")" => match (<>) {
    (lparen, Some(expr), rparen) => Some(ExprParen::new(lparen, expr, rparen)),
    _ => None,
};

Tuple<T>: PatTuple<T> = {
    "(" ")" => PatTuple::empty(<>),
    "(" T "," (T ",")* T? ")" => PatTuple::nonempty(<>),
};

Symbol: ExprSymbol = {
    "+" => ExprSymbol::Plus(<>),
    "-" => ExprSymbol::Minus(<>),
    "*" => ExprSymbol::Star(<>),
    "." => ExprSymbol::Dot(<>),
    ".." => ExprSymbol::DotDot(<>),
    ";" => ExprSymbol::Semi(<>),
    "%" => ExprSymbol::Percent(<>),
    "/" => ExprSymbol::Slash(<>),
    "=" => ExprSymbol::Equal(<>),
    "<" => ExprSymbol::Less(<>),
    ">" => ExprSymbol::Greater(<>),
    "<=" => ExprSymbol::LessEqual(<>),
    ">=" => ExprSymbol::GreaterEqual(<>),
};

Lit: ExprLit<'input> = {
    Integer => ExprLit::Integer(<>),
    Ident => ExprLit::Ident(<>),
    "true" => ExprLit::True(<>),
    "false" => ExprLit::False(<>),
};

Closure: Option<ExprClosure<'ast, 'input>> = {
    Branch => <>.map(ExprClosure::new),
    Closure "else" Branch => match (<>) {
        (Some(closure), els, Some(branch)) => Some(closure.with_branch(els, branch)),
        _ => None
    }
};

Branch: Option<ExprBranch<'ast, 'input>> = {
    "|" "|" InternalExpr => match (<>) {
        (open, close, Some(body)) => Some(ExprBranch::new(open, ExprParams::Zero, close, body)),
        _ => None,
    },
    "|" Param "|" InternalExpr => match (<>) {
        (open, Some(lhs), close, Some(body)) => Some(ExprBranch::new(open, ExprParams::One(lhs), close, body)),
        _ => None,
    },
    "|" Param "," Param "|" InternalExpr => match (<>) {
        (open, Some(lhs), comma, Some(rhs), close, Some(body)) => Some(ExprBranch::new(open, ExprParams::Two(lhs, comma, rhs), close, body)),
        _ => None,
    },
};

Param: Option<ExprParam<'ast, 'input>> = Pat (":" Type)? => match (<>) {
    (pat, Some((colon, Some(ty)))) => {
        Some(ExprParam::new(pat, Some((colon, ty))))
    },
    (pat, None) => {
        Some(ExprParam::new(pat, None))
    }
    _ => None,
};

Appl<Rhs>: Option<ExprAppl<'ast, 'input>> = Expr Term Rhs => match (<>) {
    (Some(lhs), Some(function), Some(rhs)) => Some(ExprAppl::new(lhs, function, rhs)),
    _ => None,
};

Term: Option<&'ast Expr<'ast, 'input>> = {
    Paren => <>.map(|paren| ctx.expr(Expr::Paren(paren))),
    Symbol => Some(ctx.expr(Expr::Symbol(<>))),
    Lit => Some(ctx.expr(Expr::Lit(<>))),
    Tuple<EndExpr> => <>.fold().map(|tup| ctx.expr(Expr::Tuple(tup))),
    ! => {
        errors.push(<>.error.into());
        None
    }
};

InternalTerm = {
    Term,
    Branch => <>.map(|branch| ctx.expr(Expr::Closure(ExprClosure::new(branch)))),
};

EndTerm = {
    Term,
    Closure => <>.map(|closure| ctx.expr(Expr::Closure(closure))),
};

Expr = {
    Term,
    Appl<Term> => <>.map(|appl| ctx.expr(Expr::Appl(appl))),
};

InternalExpr = {
    InternalTerm,
    Appl<InternalTerm> => <>.map(|appl| ctx.expr(Expr::Appl(appl))),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => <>.map(|appl| ctx.expr(Expr::Appl(appl))),
};
