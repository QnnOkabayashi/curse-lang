use crate::{lexer::*, Parser};
use curse_ast::ast::{
    tok, Appl, Arm, ChoiceDef, Closure, Constructor, ExplicitTypes, Expr, Field, FunctionDef,
    GenericArgs, GenericParams, Lit, NamedType, Param, Paren, Path, Pat, Program, Record, StructDef, 
    Symbol, Type, VariantDef, Variants,
    Region, RegionKind,
};

grammar<'ast>(parser: &mut Parser<'ast>);

extern {
    type Location = usize;
    type Error = LexError;

    // Any changes here must also be reflected in:
    // - curse_parse/src/lexer.rs
    // - curse_ast/src/tok.rs
    enum Token<'ast> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Literal<'ast>>),
        "type ident literal" => Token::TypeIdent(<tok::Literal<'ast>>),
        "integer literal" => Token::Integer(<tok::Literal<'ast>>),
        ":" => Token::Colon(<tok::Colon>),
        "::" => Token::ColonColon(<tok::ColonColon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        "." => Token::Dot(<tok::Dot>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "choice" => Token::Choice(<tok::Choice>),
        "struct" => Token::Struct(<tok::Struct>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Eq(<tok::Eq>),
        "<" => Token::Lt(<tok::Lt>),
        ">" => Token::Gt(<tok::Gt>),
        "<=" => Token::Le(<tok::Le>),
        ">=" => Token::Ge(<tok::Ge>),

        "true" => Token::True(<tok::True>),
        "false" => Token::False(<tok::False>),
        "ref" => Token::Ref(<tok::Ref>),
        "mut" => Token::Mut(<tok::Mut>),
    }
}

/// === Term Aliases ===

Ident: tok::Literal<'ast> = "ident literal";
TypeIdent: tok::Literal<'ast> = "type ident literal";
Integer: tok::Literal<'ast> = "integer literal";


/// === Program ===

pub Program: Program<'ast> = {
    FunctionDef => Program::default().with_function_def(<>),
    ChoiceDef => Program::default().with_choice_def(<>),
    StructDef => Program::default().with_struct_def(<>),

    Program FunctionDef => Program::with_function_def(<>),
    Program ChoiceDef => Program::with_choice_def(<>),
    Program StructDef => Program::with_struct_def(<>),

    ! => {
        parser.errors.push(<>.error.into());
        Program::default()
    }
};

/// === Definitions ===

GenericParams: GenericParams<'ast> = {
    TypeIdent => GenericParams::Single(<>),
    "(" (TypeIdent "*")* TypeIdent ")" => GenericParams::CartesianProduct(<>),
};

ExplicitTypes: ExplicitTypes<'ast> = {
    GenericParams? ":" Ref<Type> => ExplicitTypes::new(<>),
}

FunctionDef: FunctionDef<'ast> = {
    "fn" Ident ExplicitTypes? "=" Closure => FunctionDef::new(<>),
};

StructDef: StructDef<'ast> = {
    "struct" TypeIdent GenericParams? "=" Ref<Type> => StructDef::new(<>),
};

ChoiceDef: ChoiceDef<'ast> = {
    "choice" TypeIdent GenericParams? "=" Variants => ChoiceDef::new(<>),
};

Variants: Variants<'ast> = {
    "|" => Variants::Never(<>),
    "|"? (VariantDef "|")* VariantDef => Variants::Variants(<>),
}

VariantDef: VariantDef<'ast> = {
    TypeIdent Ref<Type> => VariantDef::new(<>),
};


/// === Record ===

Record<T>: Record<'ast, T> = {
    "{" (Field<T> ",")* Field<T>? "}" => Record::new(<>),
};

Field<T>: Field<'ast, T> = {
    Ident (":" T)? => Field::new(<>),
};

// Get an arena-allocated reference
Ref<T>: &'ast T = {
    T => parser.bump.alloc(<>),
}


/// === Types ===

Type: Type<'ast> = {
    NamedType => Type::Named(<>),
    Record<Ref<Type>> => Type::Record(<>),
    ! => {
        parser.errors.push(<>.error.into());
        Type::Error
    }
};

GenericArgs: GenericArgs<'ast> = {
    Ref<Type> => GenericArgs::Single(<>),
    "(" (Type "*")* Ref<Type> ")" => GenericArgs::CartesianProduct(<>),
};

NamedType: NamedType<'ast> = {
    TypePath GenericArgs? => NamedType::new(<>),
};


/// === Patterns ===

Pat: Pat<'ast> = {
    Lit => Pat::Lit(<>),
    Record<Ref<Pat>> => Pat::Record(<>),
    Constructor<Pat> => Pat::Constructor(<>),
};


/// === Shared ===

Lit: Lit<'ast> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
    "true" => Lit::True(<>),
    "false" => Lit::False(<>),
};

Path: Path<'ast> = {
    (Ident "::")* Ident => Path::new(<>),
};

TypePath: Path<'ast> = {
    (Ident "::")* TypeIdent => Path::new(<>),
};

Constructor<T>: Constructor<'ast, T> = {
    TypePath ("::" TypeIdent)? Ref<T> => Constructor::new(<>),
};


/// === Expressions ===

Symbol: Symbol = {
    "+" => Symbol::Plus(<>),
    "-" => Symbol::Minus(<>),
    "*" => Symbol::Star(<>),
    "." => Symbol::Dot(<>),
    ".." => Symbol::DotDot(<>),
    ";" => Symbol::Semi(<>),
    "%" => Symbol::Percent(<>),
    "/" => Symbol::Slash(<>),
    "=" => Symbol::Eq(<>),
    "<" => Symbol::Lt(<>),
    ">" => Symbol::Gt(<>),
    "<=" => Symbol::Le(<>),
    ">=" => Symbol::Ge(<>),
};

ClosureNonpiecewise: Closure<'ast> = {
    Arm => Closure::NonPiecewise(<>),
};

ClosurePiecewise: Closure<'ast> = {
    "(" ")" => Closure::Empty(<>),
    "(" (Arm ",")+ Arm? ")" => Closure::Piecewise(<>),
};

Closure = {
    ClosureNonpiecewise,
    ClosurePiecewise,
};

Arm: Arm<'ast> = {
    "|" (Param ",")* Param? "|" Ref<EndExpr> => Arm::new(<>),
};

Param: Param<'ast> = {
    Ref<Pat> (":" Ref<Type>)? => Param::new(<>),
};

Appl<Rhs>: Appl<'ast> = {
    Ref<Expr> Ref<Term> Ref<Rhs> => Appl::new(<>),
};

Region: Region<'ast> = {
    RegionKind Ref<Pat> "{" Ref<EndExpr> "}" => Region::new(<>),
};

RegionKind: RegionKind = {
    "ref" => RegionKind::Ref(<>),
    "mut" => RegionKind::Mut(<>),
    "ref" "mut" => RegionKind::RefMut(<>),
}

Paren: Paren<'ast> = {
    "(" Ref<EndExpr> ")" => Paren::new(<>),
};

Term: Expr<'ast> = {
    Paren => Expr::Paren(<>),
    Symbol => Expr::Symbol(<>),
    Lit => Expr::Lit(<>),
    Record<Ref<EndExpr>> => Expr::Record(<>),
    Ref<ClosurePiecewise> => Expr::Closure(<>),
    Region => Expr::Region(<>),
    ! => {
        parser.errors.push(<>.error.into());
        Expr::Error
    }
};

EndTerm = {
    Term,
    Constructor<EndExpr> => Expr::Constructor(<>),
    Ref<ClosureNonpiecewise> => Expr::Closure(<>),
};

Expr = {
    Term,
    Appl<Term> => Expr::Appl(<>),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => Expr::Appl(<>),
};
