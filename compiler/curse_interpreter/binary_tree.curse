fn of |f, x| x f {}
fn in |x, f| x f {}

choice Option |T| {
    Some T,
    None {},
}

choice Ordering {
    Less {},
    Equal {},
    Greater {},
}

fn cmp |a, b|
    (a < b) (
        |true, _| Ordering::Less {},
        |_, true| Ordering::Greater {},
        |false, false| Ordering::Equal {},
    ) (a > b)

fn then_do (
    |true, f| Option::Some (f of {}),
    |false, _| Option::None {},
)

fn then (
    |true, x| Option::Some x,
    |false, _| Option::None {},
)

fn else_do (
    |Option::Some val, _| val,
    |Option::None {}, f| f of {},
)

fn else (
    |Option::Some val, _| val,
    |Option::None {}, x| x
)

choice Tree |T| {
    Node {
        key: I32,
        value: T,
        left: Tree T,
        right: Tree T,
    },
    Empty {},
}

fn insert (
    |Tree::Empty {}, { k, v }|
        Tree::Node {
            key: k,
            value: v,
            left: Tree::Empty {},
            right: Tree::Empty {},
        },
    |Tree::Node { key, value, left, right }, { k, v }|
        k cmp key in (
            |Ordering::Greater {}| 
                right insert { k, v } in |right|
                Tree::Node { key, value, left, right },
            |Ordering::Less {}| 
                left insert { k, v } in |left|
                Tree::Node { key, value, left, right },
            |Ordering::Equal {}|
                Tree::Node { key, value: v, left, right }
        )
)

fn get (
    |Tree::Empty {}, _|
        Option::None {},
    |Tree::Node { key, value, left, right }, k|
        k cmp key in (
            |Ordering::Greater {}| right get k,
            |Ordering::Less {}| left get k,
            |Ordering::Equal {}| Option::Some value,
        )
)

fn remove (
    |Tree::Empty {}, _| Tree::Empty {},
    |Tree::Node { key, value, left, right }, k|
        k cmp key in (
            |Ordering::Less {}|
                left remove k in |left|
                Tree::Node { key, value, left, right },
            |Ordering::Greater {}|
                right remove k in |right|
                Tree::Node { key, value, left, right },
            |Ordering::Equal {}|
                { left, right } in (
                    |Tree::Empty {}, right| right,
                    |left, Tree::Empty {}| left,
                    |Tree::Node { .. }, right| 
                    
                    // go down left tree and get the max node
                    // then put that node where this one is
                    // with this one's current right and 
                    // the left with its max removed
                )
        )
)

fn max_key (
    |Tree::Empty {}| Option::None {},
    |Tree::Node { key, value, left, right }| max_key of right else_do || Option::Some { key, value },
)

fn main || (
    Tree::Empty {}
        insert { k: 2, v: 2 }
        insert { k: 1, v: 1 }
        insert { k: 0, v: 0 }
        insert { k: 3, v: 3 }
        get 3
)

