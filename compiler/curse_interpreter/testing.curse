// these simple functions work pretty well except for some reason we need
// parens in order for it to parse
fn in |x, f| x f {}
fn of |f, x| x f {}
fn inc |x| x + 1

// piecewise closures work
fn fib (
    |0| 0,
    |1| 1,
    |n| (n - 1 in fib) + (n - 2 in fib)
)

// choice declarations work
choice IntBool {
    Int I32,
    Boolean Bool,
}

fn calculate (
    |IntBool::Int n| (IntBool::Int (n + 1)),
    |IntBool::Boolean b| (IntBool::Boolean b),
)

// TODO(quinn): I broke type annotations temporarily in (#8).
// type annotations work, but function types don't appear to be supported by
// the parser and type checking seems to not work
fn inc2 |x| x + 1

// this parses
choice Result |T * E| {
    Ok T,
    Err E,
}

// this doesn't
choice Option |T| {
    Some T,
    None {},
}

struct Point {
    x: I32,
    y: I32,
}

struct Wrapper |T| {
    value: T,
    yes: Bool,
}

fn map_result (
    |Result::Ok x, f| (Result::Ok (x in f)),
    |Result::Err e, f| (Result::Err e),
)

fn add_points |{ x: x1, y: y1 }, { x: x2, y: y2 }|
    {
        x: x1 + x2,
        y: y1 + y2,
    }

// types would make this actually be `Point`s, but oh well, this works
fn main2 || { x: 1, y: 2 } add_points { x: 3, y: 4 }

// works, but doesn't parse without the parens (should it?)
fn main || (Result::Ok 3) map_result inc
