// these simple functions work pretty well except for some reason we need
// parens in order for it to parse
fn in |x, f| x f {}
fn of |f, x| x f {}
fn inc |x| x + 1

// piecewise closures work
fn fib (
    |0| 0,
    |1| 1,
    |n| (n - 1 in fib) + (n - 2 in fib)
)

// choice declarations work
choice IntBool {
    Int I32,
    Boolean Bool,
}

// for some reason, this function parses as having empty arms
fn calculate (
    |IntBool::Int n| (IntBool::Int (n + 1)),
    |IntBool::Boolean b| (IntBool::Boolean b),
)

// TODO(quinn): I broke type annotations temporarily in (#8).
// type annotations work, but function types don't appear to be supported by
// the parser and type checking seems to not work
fn inc2 |x| x + 1

// this parses
choice Result |T * E| {
    Ok T,
    Err E,
}

// this doesn't
choice Option |T| {
    Some T,
    None {},
}

struct Point {
    x: I32,
    y: I32,
}

struct Wrapper |T| {
    value: T,
    yes: Bool,
}

// this also parses, but like `calculate` for some reason parses to an empty
// function
fn map_result (
    |Result::Ok x, f| (Result::Ok (x in f)),
    |Result::Err e, f| (Result::Err e),
)

// we can instantiate an `IntBool`, but `calculate` doesn't work since it
// parses as having no arms for some reason
fn main || (Result::Ok 3) map_result inc
