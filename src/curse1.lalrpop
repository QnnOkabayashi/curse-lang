use std::str::FromStr;
use crate::ast::{Arena, Expr, Symbol, Pat, Lit, Closure, Appl, Ident, Branch};

grammar<'ast>(arena: &'ast Arena<'ast, 'input>);

Ident: Ident<'input> = r"[_a-zA-Z][_a-zA-Z0-9]{0,30}" => Ident::new(<>);

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Pat: Pat<'input> = {
    Lit => Pat::Lit(<>),
    Tuple<Pat> => Pat::Tuple(<>),
};

Comma<T>: Vec<T> = <mut v:(<T> ",")+> <e:T?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};

Paren<T>: T = "(" <T> ")";

Tuple<T>: Vec<T> = Paren<Comma<T>>;

Symbol: Symbol = {
    "()" => Symbol::Unit,
    "+" => Symbol::Plus,
    "-" => Symbol::Minus,
    "*" => Symbol::Times,
    ".." => Symbol::DotDot,
};

Lit: Lit<'input> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

Closure: Closure<'ast, 'input> = {
    Branch => Closure::new(<>),
    <closure:Closure> "else" <branch:Branch> => closure.with_branch(branch),
};

Branch: Branch<'ast, 'input> = {
    "|" "|" <body:InternalExpr> => Branch::zero(body),
    "|" <lhs:Pat> "|" <body:InternalExpr> => Branch::one(lhs, body),
    "|" <lhs:Pat> <rhs:Pat> "|" <body:InternalExpr> => Branch::two(lhs, rhs, body),
};

Appl<Rhs>: Appl<'ast, 'input> = <lhs:Expr> <f:Term> <rhs:Rhs> => Appl::new(lhs, f, rhs);

Term = {
    Paren<EndExpr>,
    Symbol => arena.symbol(<>),
    Lit => arena.lit(<>),
    Tuple<EndExpr> => arena.tuple(<>),
};

InternalTerm = {
    Term,
    Branch => arena.closure(Closure::new(<>)),
};

EndTerm = {
    Term,
    Closure => arena.closure(<>),
};

Expr = {
    Term,
    Appl<Term> => arena.appl(<>),
};

InternalExpr = {
    InternalTerm,
    Appl<InternalTerm> => arena.appl(<>),
};

pub EndExpr: &'ast Expr<'ast, 'input> = {
    EndTerm,
    Appl<EndTerm> => arena.appl(<>),
};
