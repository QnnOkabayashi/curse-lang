use std::str::FromStr;
use crate::ast::{Arena, Expr, Symbol, Pat, Lit, Closure, Appl, Ident, Branch, Program, TopLevel};

grammar<'ast>(alloc: &'ast Arena<'ast, 'input>);

pub Program: Program<'ast, 'input> = TopLevel* => Program::new(<>);

pub TopLevel: TopLevel<'ast, 'input> = "fn" <name:Ident> ":=" <body:Closure> => TopLevel::Function(name, body);

Ident: Ident<'input> = r"[_a-zA-Z][_a-zA-Z0-9]{0,30}" => Ident::new(<>);

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Pat: Pat<'input> = {
    Lit => Pat::Lit(<>),
    Tuple<Pat> => Pat::Tuple(<>),
};

Comma<T>: Vec<T> = <mut v:(<T> ",")+> <e:T?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};

Paren<T>: T = "(" <T> ")";

Tuple<T>: Vec<T> = Paren<Comma<T>>;

Symbol: Symbol = {
    "()" => Symbol::Unit,
    "+" => Symbol::Plus,
    "-" => Symbol::Minus,
    "*" => Symbol::Asterisk,
    ".." => Symbol::DotDot,
    ";" => Symbol::Semi,
    "%" => Symbol::Percent,
    "/" => Symbol::Slash,
};

Lit: Lit<'input> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

Closure: Closure<'ast, 'input> = <mut branches:(<Branch> "else")*> <last:Branch> => {
    branches.push(last);
    Closure::new(branches)
};

Branch: Branch<'ast, 'input> = {
    "|" "|" <body:InternalExpr> => Branch::zero(body),
    "|" <lhs:Pat> "|" <body:InternalExpr> => Branch::one(lhs, body),
    "|" <lhs:Pat> <rhs:Pat> "|" <body:InternalExpr> => Branch::two(lhs, rhs, body),
};

Appl<Rhs>: Appl<'ast, 'input> = <lhs:Expr> <f:Term> <rhs:Rhs> => Appl::new(lhs, f, rhs);

Term = {
    Paren<EndExpr>,
    Symbol => alloc.symbol(<>),
    Lit => alloc.lit(<>),
    Tuple<EndExpr> => alloc.tuple(<>),
};

InternalTerm = {
    Term,
    Branch => alloc.closure(Closure::new(vec![<>])),
};

EndTerm = {
    Term,
    Closure => alloc.closure(<>),
};

Expr: &'ast Expr<'ast, 'input> = {
    Term,
    Appl<Term> => alloc.appl(<>),
};

InternalExpr: &'ast Expr<'ast, 'input> = {
    InternalTerm,
    Appl<InternalTerm> => alloc.appl(<>),
};

pub EndExpr: &'ast Expr<'ast, 'input> = {
    EndTerm,
    Appl<EndTerm> => alloc.appl(<>),
};
