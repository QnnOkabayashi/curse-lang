use std::str::FromStr;
use crate::ast::{Expr, Symbol, Pat, Lit, Closure, Appl, Ident, Branch};
use typed_arena::Arena;

grammar<'ast>(arena: &'ast Arena<Expr<'ast, 'input>>);

Ident: Ident<'input> = r"[_a-zA-Z][_a-zA-Z0-9]{0,30}" => Ident::new(<>);

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Pat: Pat<'input> = {
    Lit => Pat::Lit(<>),
    Tuple<Pat> => Pat::Tuple(<>),
};

Comma<T>: Vec<T> = <mut v:(<T> ",")+> <e:T?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};

Paren<T>: T = "(" <T> ")";

Tuple<T>: Vec<T> = Paren<Comma<T>>;

Symbol: Symbol = {
    "()" => Symbol::Unit,
    "+" => Symbol::Plus,
    "-" => Symbol::Minus,
    "*" => Symbol::Times,
    ".." => Symbol::DotDot,
};

Lit: Lit<'input> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

InternalClosure: Closure<'ast, 'input> = {
    Branch => Closure::new(<>),
};

Closure: Closure<'ast, 'input> = {
    <InternalClosure>,
    <branch:Branch> ";" <mut closure:Closure> => closure.with_branch(branch),
};

Branch: Branch<'ast, 'input> = {
    "|" "|" <body:InternalExpr> => Branch::zero(body),
    "|" <lhs:Pat> "|" <body:InternalExpr> => Branch::one(lhs, body),
    "|" <lhs:Pat> <rhs:Pat> "|" <body:InternalExpr> => Branch::two(lhs, rhs, body),
};

Appl<Rhs>: Appl<'ast, 'input> = <lhs:Expr> <f:Term> <rhs:Rhs> => Appl::new(lhs, f, rhs);

Term = {
    Paren<EndExpr>,
    Symbol => arena.alloc(Expr::Symbol(<>)),
    Lit => arena.alloc(Expr::Lit(<>)),
    Tuple<EndExpr> => arena.alloc(Expr::Tuple(<>)),
};

InternalTerm = {
    Term,
    InternalClosure => arena.alloc(Expr::Closure(<>)),
};

EndTerm = {
    Term,
    Closure => arena.alloc(Expr::Closure(<>)),
};

Expr = {
    Term,
    Appl<Term> => arena.alloc(Expr::Appl(<>)),
};

InternalExpr = {
    InternalTerm,
    Appl<InternalTerm> => arena.alloc(Expr::Appl(<>)),
};

pub EndExpr: &'ast Expr<'ast, 'input> = {
    EndTerm,
    Appl<EndTerm> => arena.alloc(Expr::Appl(<>)),
};
