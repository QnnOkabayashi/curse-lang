use std::str::FromStr;
use crate::ast::{Expr, Symbol, Pat, Lit, Closure, Appl};
use typed_arena::Arena;

grammar<'ast>(arena: &'ast Arena<Expr<'ast, 'input>>);

Ident: &'input str = r"[_a-zA-Z][_a-zA-Z0-9]{0,30}";

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Pat: Pat<'input> = {
    Ident => Pat::Ident(<>),
    "(" <Comma<Pat>> ")" => Pat::Tuple(<>),
};

Comma<T>: Vec<T> = <mut v:(<T> ",")*> <e:T?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};

Symbol: Symbol = {
    "()" => Symbol::Unit,
    "+" => Symbol::Plus,
    "-" => Symbol::Minus,
    "*" => Symbol::Times,
    ".." => Symbol::DotDot,
    ";" => Symbol::Semi,
};

Lit: Lit<'input> = {
    Symbol => Lit::Symbol(<>),
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

Closure: Closure<'ast, 'input> = {
    "|" "|" <body:EndExpr> => Closure::zero(body),
    "|" <p1:Pat> "|" <body:EndExpr> => Closure::one(p1, body),
    "|" <p1:Pat> <p2:Pat> "|" <body:EndExpr> => Closure::two(p1, p2, body),
};

Term: &'ast Expr<'ast, 'input> = {
    "(" <EndExpr> ")",
    Lit => arena.alloc(Expr::Lit(<>))
};

EndTerm: &'ast Expr<'ast, 'input> = {
    Term,
    Closure => arena.alloc(Expr::Closure(<>)),
};

Expr: &'ast Expr<'ast, 'input> = {
    Term,
    <p1:Expr> <f:Term> <p2:Term> => arena.alloc(Expr::Appl(Appl::new(p1, f, p2))),
};

pub EndExpr: &'ast Expr<'ast, 'input> = {
    EndTerm,
    <p1:Expr> <f:Term> <p2:EndTerm> => arena.alloc(Expr::Appl(Appl::new(p1, f, p2))),
};
