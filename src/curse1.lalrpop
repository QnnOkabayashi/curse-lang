use std::str::FromStr;
use crate::ast::{Expr, Symbol, Pat, Lit, Closure, Appl, Ident};
use typed_arena::Arena;

grammar<'ast>(arena: &'ast Arena<Expr<'ast, 'input>>);

Ident: Ident<'input> = r"[_a-zA-Z][_a-zA-Z0-9]{0,30}" => Ident::new(<>);

Integer: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Pat<Item>: Pat<Item> = {
    Item => Pat::Item(<>),
    "(" <Comma<Pat<Item>>> ")" => Pat::Tuple(<>),
};

Comma<T>: Vec<T> = <mut v:(<T> ",")+> <e:T?> => {
    if let Some(e) = e {
        v.push(e);
    }
    v
};

Symbol: Symbol = {
    "()" => Symbol::Unit,
    "+" => Symbol::Plus,
    "-" => Symbol::Minus,
    "*" => Symbol::Times,
    ".." => Symbol::DotDot,
    ";" => Symbol::Semi,
};

Lit: Lit<'input> = {
    Symbol => Lit::Symbol(<>),
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

Closure: Closure<'ast, 'input> = {
    "|" "|" <body:EndExpr> => Closure::zero(body),
    "|" <p1:Pat<Ident>> "|" <body:EndExpr> => Closure::one(p1, body),
    "|" <p1:Pat<Ident>> <p2:Pat<Ident>> "|" <body:EndExpr> => Closure::two(p1, p2, body),
};

Term: &'ast Expr<'ast, 'input> = {
    "(" <EndExpr> ")",
    Pat<Lit> => arena.alloc(Expr::Pat(<>))
};

EndTerm: &'ast Expr<'ast, 'input> = {
    Term,
    Closure => arena.alloc(Expr::Closure(<>)),
};

Expr: &'ast Expr<'ast, 'input> = {
    Term,
    <p1:Expr> <f:Term> <p2:Term> => arena.alloc(Expr::Appl(Appl::new(p1, f, p2))),
};

pub EndExpr: &'ast Expr<'ast, 'input> = {
    EndTerm,
    <p1:Expr> <f:Term> <p2:EndTerm> => arena.alloc(Expr::Appl(Appl::new(p1, f, p2))),
};
