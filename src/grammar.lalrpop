use crate::ast::{
    Appl, Arena, Branch, Closure, Expr, ItemFunction, Lit, Paren, Pat, Program, Symbol, Item,
    Tuple, types, types::Type,
};
use crate::lex::{tok, LexError, Token};

grammar<'ast, 'input>(alloc: &'ast Arena<'ast, 'input>);

extern {
    type Location = usize;
    type Error = LexError;

    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "else" => Token::Else(<tok::Else>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Equal(<tok::Equal>),
        "<" => Token::Less(<tok::Less>),
        ">" => Token::Greater(<tok::Greater>),
        "<=" => Token::LessEqual(<tok::LessEqual>),
        ">=" => Token::GreaterEqual(<tok::GreaterEqual>),
    }
}

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

pub Program: Program<'ast, 'input> = Item* => Program::new(<>);

pub Item: Item<'ast, 'input> = "fn" Ident ":" Type "=" Closure => Item::Function(ItemFunction::new(<>));

StartType: &'ast Type<'ast, 'input> = {
    Ident => alloc.typ(Type::Named(types::Named::new(<>))),
    Tuple<Type> => alloc.typ(Type::Tuple(types::Tuple::new(<>))),
    "(" <Type> ")",
};

Type = {
    StartType StartType "->" Type => alloc.typ(Type::Function(types::Function::new(<>))),
    StartType,
};

Pat: &'ast Pat<'ast, 'input> = {
    Lit => alloc.pat(Pat::Lit(<>)),
    Tuple<Pat> => alloc.pat(Pat::Tuple(<>)),
};

Paren: Paren<'ast, 'input> = "(" EndExpr ")" => Paren::new(<>);

Tuple<T>: Tuple<T> = {
    "(" ")" => Tuple::unit(<>),
    "(" (T ",")+ T? ")" => Tuple::new(<>),
}

Symbol: Symbol = {
    "+" => Symbol::Plus(<>),
    "-" => Symbol::Minus(<>),
    "*" => Symbol::Star(<>),
    ".." => Symbol::DotDot(<>),
    ";" => Symbol::Semi(<>),
    "%" => Symbol::Percent(<>),
    "/" => Symbol::Slash(<>),
    "=" => Symbol::Equal(<>),
    "<" => Symbol::Less(<>),
    ">" => Symbol::Greater(<>),
    "<=" => Symbol::LessEqual(<>),
    ">=" => Symbol::GreaterEqual(<>),
};

Lit: Lit<'input> = {
    Integer => Lit::Integer(<>),
    Ident => Lit::Ident(<>),
};

Closure: Closure<'ast, 'input> = (Branch "else")* Branch => Closure::new(<>);

Branch: Branch<'ast, 'input> = {
    "|" "|" InternalExpr => Branch::zero(<>),
    "|" Pat "|" InternalExpr => Branch::one(<>),
    "|" Pat Pat "|" InternalExpr => Branch::two(<>),
};

Appl<Rhs>: Appl<'ast, 'input> = Expr Term Rhs => Appl::new(<>);

Term: &'ast Expr<'ast, 'input> = {
    Paren => alloc.expr(Expr::Paren(<>)),
    Symbol => alloc.expr(Expr::Symbol(<>)),
    Lit => alloc.expr(Expr::Lit(<>)),
    Tuple<EndExpr> => alloc.expr(Expr::Tuple(<>)),
    ! => alloc.expr(Expr::Error(<>)),
};

InternalTerm = {
    Term,
    Branch => alloc.expr(Expr::Closure(Closure::new(vec![], <>))),
};

EndTerm = {
    Term,
    Closure => alloc.expr(Expr::Closure(<>)),
};

Expr = {
    Term,
    Appl<Term> => alloc.expr(Expr::Appl(<>)),
};

InternalExpr = {
    InternalTerm,
    Appl<InternalTerm> => alloc.expr(Expr::Appl(<>)),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => alloc.expr(Expr::Appl(<>)),
};
