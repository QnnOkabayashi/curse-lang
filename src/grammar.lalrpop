use crate::ast::{expr, pat, ty, Arena, Item, ItemFunction, Program};
use crate::lex::{tok, LexError, Token};

grammar<'ast, 'input>(alloc: &'ast Arena<'ast, 'input>);

extern {
    type Location = usize;
    type Error = LexError;

    enum Token<'input> {
        // In the grammar, if we specify the string on the lhs,
        // it means that we're waiting for the lexer to
        // give us the rhs.
        "ident literal" => Token::Ident(<tok::Ident<'input>>),
        "integer literal" => Token::Integer(<tok::Integer<'input>>),
        ":" => Token::Colon(<tok::Colon>),
        "," => Token::Comma(<tok::Comma>),
        "(" => Token::LParen(<tok::LParen>),
        ")" => Token::RParen(<tok::RParen>),
        "+" => Token::Plus(<tok::Plus>),
        "-" => Token::Minus(<tok::Minus>),
        "*" => Token::Star(<tok::Star>),
        ".." => Token::DotDot(<tok::DotDot>),
        ";" => Token::Semi(<tok::Semi>),
        "%" => Token::Percent(<tok::Percent>),
        "/" => Token::Slash(<tok::Slash>),
        "|" => Token::Pipe(<tok::Pipe>),
        "fn" => Token::Fn(<tok::Fn>),
        "else" => Token::Else(<tok::Else>),
        "struct" => Token::Struct(<tok::Struct>),
        "enum" => Token::Enum(<tok::Enum>),
        "{" => Token::LBrace(<tok::LBrace>),
        "}" => Token::RBrace(<tok::RBrace>),
        "->" => Token::Arrow(<tok::Arrow>),

        "=" => Token::Equal(<tok::Equal>),
        "<" => Token::Less(<tok::Less>),
        ">" => Token::Greater(<tok::Greater>),
        "<=" => Token::LessEqual(<tok::LessEqual>),
        ">=" => Token::GreaterEqual(<tok::GreaterEqual>),
    }
}

Ident: tok::Ident<'input> = "ident literal";

Integer: tok::Integer<'input> = "integer literal";

pub Program: Program<'ast, 'input> = Item* => Program::new(<>);

pub Item: Item<'ast, 'input> = "fn" Ident ":" Type "=" Closure => Item::Function(ItemFunction::new(<>));

StartType: &'ast ty::Type<'ast, 'input> = {
    Ident => alloc.typ(ty::Type::Named(ty::Named::new(<>))),
    Tuple<Type> => alloc.typ(ty::Type::Tuple(ty::Tuple::new(<>))),
    "(" <Type> ")",
};

Type = {
    StartType StartType "->" Type => alloc.typ(ty::Type::Function(ty::Function::new(<>))),
    StartType,
};

Pat: &'ast expr::Pat<'ast, 'input> = {
    Lit => alloc.pat(expr::Pat::Lit(<>)),
    Tuple<Pat> => alloc.pat(expr::Pat::Tuple(<>)),
};

Paren: expr::Paren<'ast, 'input> = "(" EndExpr ")" => expr::Paren::new(<>);

Tuple<T>: pat::Tuple<T> = {
    "(" ")" => pat::Tuple::empty(<>),
    "(" T "," (T ",")* T? ")" => pat::Tuple::nonempty(<>),
}

Symbol: expr::Symbol = {
    "+" => expr::Symbol::Plus(<>),
    "-" => expr::Symbol::Minus(<>),
    "*" => expr::Symbol::Star(<>),
    ".." => expr::Symbol::DotDot(<>),
    ";" => expr::Symbol::Semi(<>),
    "%" => expr::Symbol::Percent(<>),
    "/" => expr::Symbol::Slash(<>),
    "=" => expr::Symbol::Equal(<>),
    "<" => expr::Symbol::Less(<>),
    ">" => expr::Symbol::Greater(<>),
    "<=" => expr::Symbol::LessEqual(<>),
    ">=" => expr::Symbol::GreaterEqual(<>),
};

Lit: expr::Lit<'input> = {
    Integer => expr::Lit::Integer(<>),
    Ident => expr::Lit::Ident(<>),
};

Closure: expr::Closure<'ast, 'input> = (Branch "else")* Branch => expr::Closure::new(<>);

Branch: expr::Branch<'ast, 'input> = {
    "|" "|" InternalExpr => expr::Branch::zero(<>),
    "|" Param "|" InternalExpr => expr::Branch::one(<>),
    "|" Param "," Param "|" InternalExpr => expr::Branch::two(<>),
};

Param: expr::Param<'ast, 'input> = Pat (":" Type)? => expr::Param::new(<>);

Appl<Rhs>: expr::Appl<'ast, 'input> = Expr Term Rhs => expr::Appl::new(<>);

Term: &'ast expr::Expr<'ast, 'input> = {
    Paren => alloc.expr(expr::Expr::Paren(<>)),
    Symbol => alloc.expr(expr::Expr::Symbol(<>)),
    Lit => alloc.expr(expr::Expr::Lit(<>)),
    Tuple<EndExpr> => alloc.expr(expr::Expr::Tuple(<>)),
    ! => alloc.expr(expr::Expr::Error(<>)),
};

InternalTerm = {
    Term,
    Branch => alloc.expr(expr::Expr::Closure(expr::Closure::new(vec![], <>))),
};

EndTerm = {
    Term,
    Closure => alloc.expr(expr::Expr::Closure(<>)),
};

Expr = {
    Term,
    Appl<Term> => alloc.expr(expr::Expr::Appl(<>)),
};

InternalExpr = {
    InternalTerm,
    Appl<InternalTerm> => alloc.expr(expr::Expr::Appl(<>)),
};

pub EndExpr = {
    EndTerm,
    Appl<EndTerm> => alloc.expr(expr::Expr::Appl(<>)),
};
